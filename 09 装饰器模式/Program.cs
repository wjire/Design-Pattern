using System;
using System.IO;

namespace _09_装饰器模式
{
    internal class Program
    {
        private static void Main(string[] args)
        {

            /*
            动态的将行为附加到对象上.若要扩展功能,装饰者提供了比继承更有弹性的替代方案.


            *装饰模式的应用场景
               装饰模式通常在以下几种情况使用。
               当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。
               当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。
               当对象的功能要求可以动态地添加，也可以再动态地撤销时。
          
   
            机器人装饰器基类是装饰模式的核心
            装饰器类需要继承自机器人抽象类,因为给机器人装饰完了,它依然是个机器人!!!
            *
            * 装饰器模式与代理模式很相近,两者解决的问题都是找第三方来解决问题.
            * 不同的是,装饰器是横向的,代理模式是纵向的.
            * 或者说,装饰器是可以随意水平扩展的,更像一个团队,而代理模式是一个人.
            * 从代码上看,代理模式只会创建一个对象,而装饰器模式则会创建多个对象,因为是团队嘛.
            * 另外,代理模式中,代理类和真实类是组合的关系,代理类只能代理某个真实类,
            * 而装饰器模式中,装饰器类和具体类(真实类)没有关系,装饰器类组合的是基类,所以装饰器可以装饰任意实现类.
             

            装饰器模式和适配器模式都是对对象的封装,
                1.装饰者的基类和被装饰者只是同一父类的不同子类;适配器和被适配者是同一接口的不同实现.
                2.适配器不关心行为的具体实现,主动去适配的一方,可以有任意的实现;而每一个装饰器都不知道传给他的对象是否已经被装饰过了,或者被多少装饰器装饰过了.它只负责给传入的对象添加上它的行为实现.
            但,二者实际区别还是很大.
            1.装饰器模式可以在运行时,动态的添加行为,强调的是行为的多样性.
            2.适配器模式并不是添加行为,而是隐藏了行为的具体实现;并且适配器的行为是静态的,程序运行起来后,它的行为就固定了,你只能适配特定的接口,而无法适配其他的接口.适配器模式强调的是如何让行为适配.
            
            装饰 是个形容词,强调的是外在表现;而适配 是个动词,强调的是行为对接
            
            二者都有明显的缺点
            1.当需要很多行为时,装饰器的子类会非常的多.
            2.当被适配的接口的行为很多时,主动适配的一方则需要实现所有的行为.

            */


            //创建一个机器人
            BaseRobot robot = new Robot();

            robot = new CookRobotDecorator(robot);
            robot = new EmailRobotDecorator(robot);
            robot = new CleanRobotDecorator(robot);

            robot.DoSomething();
            Console.ReadKey();
        }
    }
}
